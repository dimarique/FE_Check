[
  {
    "id": 101,
    "question": "Was wird in React anstelle von Schleifen zum Rendern von Listen verwendet?",
    "answer": "Die Array-Methode map.",
    "category": "React: Rendering",
    "difficulty": "easy"
  },
  {
    "id": 102,
    "question": "Warum ist es wichtig, das Attribut key beim Rendern von Listen anzugeben?",
    "answer": "Zur Leistungsoptimierung und für die korrekte Aktualisierung der Elemente.",
    "category": "React: Rendering",
    "difficulty": "medium"
  },
  {
    "id": 103,
    "question": "Warum wird nicht empfohlen, den Array-Index als key zu verwenden?",
    "answer": "Weil dies bei Änderungen in der Liste zu Fehlern führt.",
    "category": "React: Rendering",
    "difficulty": "medium"
  },
  {
    "id": 104,
    "question": "Wie werden Objekte und Arrays in Props übergeben?",
    "answer": "In geschweiften Klammern als dynamische Werte.",
    "category": "React: Props",
    "difficulty": "easy"
  },
  {
    "id": 105,
    "question": "Was macht das spezielle Prop children?",
    "answer": "Es übergibt den Inhalt zwischen dem öffnenden und schließenden Tag einer Komponente.",
    "category": "React: Props",
    "difficulty": "easy"
  },
  {
    "id": 106,
    "question": "Wie werden Ereignis-Handler in React hinzugefügt?",
    "answer": "Über Attribute in JSX im camelCase-Stil, z. B. onClick.",
    "category": "React: Events",
    "difficulty": "easy"
  },
  {
    "id": 107,
    "question": "Was ist ein SyntheticEvent?",
    "answer": "Ein plattformübergreifender Wrapper für native Browser-Ereignisse in React.",
    "category": "React: Events",
    "difficulty": "medium"
  },
  {
    "id": 108,
    "question": "Wie kann man verhindern, dass sich die Seite neu lädt, wenn man auf eine Schaltfläche in einem Formular klickt?",
    "answer": "Mit event.preventDefault().",
    "category": "React: Events",
    "difficulty": "easy"
  },
  {
    "id": 109,
    "question": "Warum übergibt man Funktionen in Props?",
    "answer": "Damit sie in der Kindkomponente bei einem Ereignis aufgerufen werden können.",
    "category": "React: Props",
    "difficulty": "medium"
  },
  {
    "id": 110,
    "question": "Wofür verwendet man eine Wrapper-Komponente mit children?",
    "answer": "Um verschachtelte Elemente in einem gemeinsamen Container mit gewünschtem Layout oder Stil zu umschließen.",
    "category": "React: Props",
    "difficulty": "easy"
  },
  {
    "id": 111,
    "question": "Was ist der lokale Zustand (State) einer Komponente in React?",
    "answer": "Ein interner Speicher der Komponente, der zwischen Renderings bestehen bleibt und bei Änderungen einen neuen Render auslöst.",
    "category": "React: State",
    "difficulty": "easy"
  },
  {
    "id": 112,
    "question": "Warum kann man keine einfache lokale Variable anstelle von State verwenden?",
    "answer": "Weil sie beim Re-Render verloren geht und ihre Änderung keine Neurenderung auslöst.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 113,
    "question": "Was ist der Hook useState?",
    "answer": "Eine React-Funktion, die das Erstellen und Verwalten eines lokalen Zustands ermöglicht.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 114,
    "question": "Was gibt der Hook useState zurück?",
    "answer": "Ein Array mit zwei Elementen: dem aktuellen Zustand und einer Funktion zu dessen Aktualisierung.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 115,
    "question": "Mit welchem Wert wird der State beim ersten Render initialisiert?",
    "answer": "Mit dem Wert, der als Argument an useState übergeben wird.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 116,
    "question": "Warum darf man den Zustand nicht direkt verändern?",
    "answer": "Weil React die Änderung sonst nicht erkennt und kein Re-Render plant.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 117,
    "question": "Welche Regeln muss man bei der Verwendung von Hooks beachten?",
    "answer": "Sie dürfen nur auf oberster Ebene der Komponente und nicht innerhalb von Bedingungen aufgerufen werden.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 118,
    "question": "Was passiert, wenn man den Zustand über setState ändert?",
    "answer": "React plant ein erneutes Rendern der Komponente.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 119,
    "question": "Wo sollte man den Zustand speichern, um die Leistung zu optimieren?",
    "answer": "Auf der niedrigsten Ebene der Komponenten-Hierarchie, wo er tatsächlich benötigt wird.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 120,
    "question": "Kann man mehrere Zustände in einer Komponente verwenden?",
    "answer": "Ja, useState kann mehrfach aufgerufen werden, und jeder Zustand ist unabhängig.",
    "category": "React: State",
    "difficulty": "easy"
  },
  {
    "id": 121,
    "question": "Was kann man im lokalen Zustand außer primitiven Werten speichern?",
    "answer": "Man kann auch Objekte, Arrays und andere nicht-primitiven Werte speichern.",
    "category": "React: State",
    "difficulty": "easy"
  },
  {
    "id": 122,
    "question": "Warum darf man ein Array oder Objekt im Zustand nicht direkt verändern?",
    "answer": "Weil dies den State mutiert, und React keinen Grund sieht, neu zu rendern.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 123,
    "question": "Wie aktualisiert man ein Array im lokalen Zustand richtig?",
    "answer": "Ein neues Array auf Basis des alten erstellen und es an setState übergeben.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 124,
    "question": "Was macht die Callback-Form setState(oldState => newState)?",
    "answer": "Sie ermöglicht, den neuen Zustand auf Basis des vorherigen zu berechnen.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 125,
    "question": "Wie aktualisiert man ein Objekt im lokalen Zustand?",
    "answer": "Ein neues Objekt mit den geänderten Eigenschaften erstellen und an setState übergeben.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 126,
    "question": "Was bedeutet Lifting State Up?",
    "answer": "Das Verschieben des Zustands in die nächste gemeinsame Elternkomponente, die ihn benötigt, und die Weitergabe über Props.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 127,
    "question": "Warum sollte man den Zustand nur bis zum nächsten gemeinsamen Elternteil heben?",
    "answer": "Um unnötige Re-Renders zu vermeiden und keine Daten durch überflüssige Komponenten weiterzugeben.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 128,
    "question": "Wie kann man Daten zwischen mehreren Komponenten teilen?",
    "answer": "Den Zustand in eine gemeinsame Elternkomponente heben und über Props weitergeben.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 129,
    "question": "Was passiert, wenn man ein Array im State mit push verändert?",
    "answer": "React rendert die Komponente nicht neu, da sich die Speicherreferenz nicht geändert hat.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 130,
    "question": "Wie implementiert man das Hinzufügen eines neuen Elements in einer To-do-Liste?",
    "answer": "Mit setState, indem man ein neues Array erstellt, das die alten Elemente und das neue enthält.",
    "category": "React: State",
    "difficulty": "medium"
  },
  {
    "id": 131,
    "question": "Was macht der Hook useEffect?",
    "answer": "Er synchronisiert die Komponente mit einem externen System und führt Side Effects aus.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 132,
    "question": "Was versteht man in React unter Side Effects?",
    "answer": "Aktionen nach dem Rendern, die den aktuellen Render nicht direkt beeinflussen – z. B. Anfragen, Abonnements, DOM-Manipulationen, Timer oder Arbeit mit localStorage.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 133,
    "question": "Welche Phasen des Lebenszyklus hat eine Funktionskomponente?",
    "answer": "Mounting, Updating, Unmounting.",
    "category": "React: Lifecycle",
    "difficulty": "easy"
  },
  {
    "id": 134,
    "question": "Wie lautet die Syntax von useEffect und wozu dient das Abhängigkeitsarray?",
    "answer": "useEffect(callback, deps) – das Array legt fest, wann der Effekt ausgeführt wird.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 135,
    "question": "Wann wird ein Effekt ohne Abhängigkeitsarray ausgeführt?",
    "answer": "Nach jedem Render, also beim Mounting und bei jeder Aktualisierung.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 136,
    "question": "Was bedeutet ein leeres Abhängigkeitsarray?",
    "answer": "Der Effekt wird einmal beim Mounting ausgeführt, und die Cleanup-Funktion beim Unmounting.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 137,
    "question": "Wie kann man eine Aktion beim Unmounting der Komponente ausführen?",
    "answer": "Man gibt aus dem Effekt eine Cleanup-Funktion zurück, die beim Entfernen der Komponente aus dem DOM ausgeführt wird.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 138,
    "question": "Wie kann man eine Änderung eines bestimmten Props oder States überwachen?",
    "answer": "Indem man sie ins Abhängigkeitsarray einträgt – der Effekt wird bei deren Änderung ausgeführt.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 139,
    "question": "Wo dürfen Effekte platziert werden und kann man mehrere haben?",
    "answer": "Nur auf oberster Ebene der Komponente – und ja, man kann mehrere useEffects haben.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 140,
    "question": "Wofür wird useEffect typischerweise verwendet?",
    "answer": "Für API-Anfragen, WebSockets, Event-Listener, Timer, Intervalle oder Arbeit mit localStorage.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 141,
    "question": "Wofür wird useEffect meist beim Arbeiten mit Netzwerkanfragen verwendet?",
    "answer": "Zum Senden von Anfragen an den Server und zur Synchronisierung der Komponentendaten mit dem Backend.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 142,
    "question": "Warum sollte man keine Anfrage direkt im Komponentenrumpf ausführen?",
    "answer": "Weil sie bei jedem Re-Render erneut ausgeführt würde.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 143,
    "question": "In welcher Lebenszyklusphase werden Netzwerkanfragen üblicherweise gestartet?",
    "answer": "In der Mounting-Phase.",
    "category": "React: Lifecycle",
    "difficulty": "easy"
  },
  {
    "id": 144,
    "question": "Warum fügt man productId ins Abhängigkeitsarray des Effekts ein?",
    "answer": "Damit der Effekt ausgelöst wird, wenn sich die Produkt-ID ändert.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 145,
    "question": "Wie zeigt man die aus einer Anfrage erhaltenen Daten auf dem Bildschirm an?",
    "answer": "Man speichert sie im lokalen State und nutzt sie im Render.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 146,
    "question": "Was passiert, wenn man im useEffect kein Abhängigkeitsarray angibt?",
    "answer": "Der Effekt wird nach jedem Render ausgeführt.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 147,
    "question": "Wie behandelt man Fehler bei Netzwerkanfragen?",
    "answer": "Mit try...catch oder mit Fehlerbehandlung in then()/catch().",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 148,
    "question": "Wie kann man einen Ladeindikator (Loading) implementieren?",
    "answer": "Einen separaten State 'loading' verwenden und während der Anfrage eine Meldung oder einen Spinner anzeigen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 149,
    "question": "Warum sollte man async/await innerhalb von useEffect verwenden?",
    "answer": "Weil man damit asynchronen Code übersichtlicher und lesbarer schreiben kann.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 150,
    "question": "Wie kann man eine Produktfilterung nach Kategorien umsetzen?",
    "answer": "Die Kategorien abrufen, sie in einem Dropdown rendern und bei Auswahl eine Anfrage für die Produkte der gewählten Kategorie senden.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 151,
    "question": "Warum verwendet man den Context in React?",
    "answer": "Um Prop Drilling zu vermeiden und Daten zwischen Komponenten auf verschiedenen Ebenen zu teilen.",
    "category": "React: Context",
    "difficulty": "medium"
  },
  {
    "id": 152,
    "question": "Was ist Prop Drilling?",
    "answer": "Das Durchreichen von Props durch mehrere Zwischenkomponenten, die die Daten selbst nicht benötigen.",
    "category": "React: Context",
    "difficulty": "medium"
  },
  {
    "id": 153,
    "question": "Wie erstellt man einen Context?",
    "answer": "Mit createContext(initialValue) und Export des erzeugten Context-Objekts.",
    "category": "React: Context",
    "difficulty": "easy"
  },
  {
    "id": 154,
    "question": "Wozu dient der Provider eines Contexts?",
    "answer": "Er umschließt einen Teil des Komponentenbaums und übergibt über das value-Prop Werte an alle darunterliegenden Komponenten.",
    "category": "React: Context",
    "difficulty": "easy"
  },
  {
    "id": 155,
    "question": "Wie greift man in einer Komponente auf den Context-Wert zu?",
    "answer": "Mit useContext(MyContext).",
    "category": "React: Context",
    "difficulty": "easy"
  },
  {
    "id": 156,
    "question": "Was passiert, wenn man beim Provider kein value angibt?",
    "answer": "Dann wird der Standardwert aus createContext verwendet.",
    "category": "React: Context",
    "difficulty": "easy"
  },
  {
    "id": 157,
    "question": "Wann sollte man Context statt Lifting State Up verwenden?",
    "answer": "Wenn Daten von vielen Komponenten auf unterschiedlichen Ebenen benötigt werden und das Prop-Weiterreichen zu kompliziert wäre.",
    "category": "React: Context",
    "difficulty": "medium"
  },
  {
    "id": 158,
    "question": "Kann man im Context Objekte und Funktionen speichern?",
    "answer": "Ja, im value können beliebige Werte enthalten sein, auch Objekte und Callbacks.",
    "category": "React: Context",
    "difficulty": "easy"
  },
  {
    "id": 159,
    "question": "Wie verbindet man Context mit lokalem State?",
    "answer": "Den State im Elternkomponenten speichern und über value sowohl Wert als auch Update-Funktion übergeben.",
    "category": "React: Context",
    "difficulty": "medium"
  },
  {
    "id": 160,
    "question": "Warum sollte man den Provider in eine separate Komponente wie ThemeContextProvider auslagern?",
    "answer": "Um Zustand und Logik des Contexts zu kapseln und dessen Verwendung im gesamten Projekt zu vereinfachen.",
    "category": "React: Context",
    "difficulty": "medium"
  }, 
  {
    "id": 161,
    "question": "Wozu dient der Hook useRef?",
    "answer": "Zum Zugriff auf echte DOM-Elemente und zum Speichern von Werten zwischen Rendern, ohne ein Re-Render auszulösen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 162,
    "question": "Woran kann man ein ref anhängen?",
    "answer": "Nur an DOM-Elemente; der Verweis ist unter der Eigenschaft current verfügbar.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 163,
    "question": "Wie erhält man über ein ref die Größe eines Elements?",
    "answer": "Mit btnRef.current.offsetWidth und btnRef.current.offsetHeight.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 164,
    "question": "Worin unterscheidet sich ref vom State aus useState?",
    "answer": "ref ist veränderbar und seine Änderung löst kein Re-Render aus; useState triggert ein Re-Render.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 165,
    "question": "Wie setzt man beim ersten Render den Fokus auf ein Input-Feld?",
    "answer": "Ein ref erstellen und im Effekt inputRef.current.focus() aufrufen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 166,
    "question": "Kann man den Wert eines Inputs über ref ohne State auslesen?",
    "answer": "Ja, über inputRef.current.value.",
    "category": "React: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 167,
    "question": "Warum verwendet man react-hook-form?",
    "answer": "Um die Arbeit mit Formularen und Validierung zu vereinfachen – ohne unnötige Re-Renders.",
    "category": "React: Forms",
    "difficulty": "medium"
  },
  {
    "id": 168,
    "question": "Was liefert useForm zurück und wozu dienen register und handleSubmit?",
    "answer": "register registriert Felder, handleSubmit verarbeitet das Absenden mit Validierung.",
    "category": "React: Forms",
    "difficulty": "medium"
  },
  {
    "id": 169,
    "question": "Woher bekommt man die Fehlermeldungen der Felder und wie rendert man sie?",
    "answer": "Aus formState.errors; per bedingtem Rendern unter den Inputs anzeigen.",
    "category": "React: Forms",
    "difficulty": "medium"
  },
  {
    "id": 170,
    "question": "Wie definiert man Validierungsregeln und Nachrichten in register?",
    "answer": "Ein Objekt mit required, minLength, maxLength, pattern oder validate übergeben und je eine message angeben.",
    "category": "React: Forms",
    "difficulty": "medium"
  },
  {
    "id": 171,
    "question": "Was macht die Bibliothek react-router in einer React-App?",
    "answer": "Sie ermöglicht Routing und simuliert Mehrseitigkeit in einer SPA.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 172,
    "question": "Warum umschließt man die App mit BrowserRouter?",
    "answer": "Um Routing zu aktivieren und den Kontext für die Routen bereitzustellen.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 173,
    "question": "Welche Komponenten verwendet man zum Definieren von Routen?",
    "answer": "Die Komponenten Routes und Route.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 174,
    "question": "Was macht das Prop path der Komponente Route?",
    "answer": "Es gibt an, unter welcher Adresse die Komponente gerendert wird.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 175,
    "question": "Wie definiert man eine Standardroute?",
    "answer": "Man setzt path=\"/\" für die gewünschte Komponente.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 176,
    "question": "Wie rendert man eine Komponente bei jeder Route?",
    "answer": "Man platziert sie außerhalb der Routes-Umhüllung.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 177,
    "question": "Was sind verschachtelte Routen (Nested Routes)?",
    "answer": "Routen innerhalb anderer Routen, die im Outlet der Elternkomponente angezeigt werden.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 178,
    "question": "Wofür wird die Komponente Outlet verwendet?",
    "answer": "Um die Stelle im Elternteil anzugeben, an der die verschachtelte Route gerendert wird.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 179,
    "question": "Worin unterscheiden sich Link und NavLink?",
    "answer": "Link navigiert einfach zur Route, NavLink kann zudem einen aktiven Zustand anzeigen.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 180,
    "question": "Warum sind Links im Router besser als das manuelle Eingeben der Adresse?",
    "answer": "Sie ermöglichen Navigation innerhalb der SPA ohne Seitenneuladen.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 181,
    "question": "Was ist eine parametrisierte Route?",
    "answer": "Eine Route, in der ein Teil des Pfads dynamisch über :paramName definiert wird, z. B. /details/:id.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 182,
    "question": "Wozu dienen parametrisierte Routen?",
    "answer": "Um Daten über die URL zu übergeben, z. B. eine Produkt-ID zur Anzeige der Details.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 183,
    "question": "Wie erhält man die Routenparameter in einer Komponente?",
    "answer": "Mit dem Hook useParams, der ein Objekt mit den Parametern zurückgibt.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 184,
    "question": "Was gibt useParams bei der Route /products/5 und path=\"/products/:id\" zurück?",
    "answer": "Das Objekt { id: \"5\" }.",
    "category": "React: Router",
    "difficulty": "easy"
  },
  {
    "id": 185,
    "question": "Wie macht man einen Parameter optional?",
    "answer": "Ein Fragezeichen hinzufügen, z. B. :id?.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 186,
    "question": "Was passiert, wenn ein optionaler Parameter in der URL fehlt?",
    "answer": "Die Komponente wird trotzdem gerendert; der Parameter ist undefined.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 187,
    "question": "Kann man mehrere Parameter in einer Route verwenden?",
    "answer": "Ja, z. B. /shop/:category/:productId.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 188,
    "question": "Worin unterscheidet sich die Datenweitergabe über Context von der über URL-Parameter?",
    "answer": "Context wird innerhalb der React-App genutzt; URL-Parameter sind praktisch für Navigation und direkte Links.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 189,
    "question": "Wie nutzt man den Kategorien-Parameter zur Produktfilterung?",
    "answer": "Die Kategorie mit useParams auslesen und in die API-Anfrage einsetzen.",
    "category": "React: Router",
    "difficulty": "medium"
  },
  {
    "id": 190,
    "question": "Was passiert beim Aufruf von /products ohne Parameter, wenn die Route als /products/:category? definiert ist?",
    "answer": "Dieselbe Komponente wird gerendert, aber der Kategorien-Parameter ist leer; man kann dann alle Produkte anzeigen.",
    "category": "React: Router",
    "difficulty": "medium"
  }, 
  {
    "id": 191,
    "question": "Was wird im Redux Store gespeichert?",
    "answer": "Der globale Zustand der Anwendung, strukturiert nach einzelnen Slices (Reducers).",
    "category": "Redux: Basics",
    "difficulty": "easy"
  },
  {
    "id": 192,
    "question": "Wozu dienen Actions?",
    "answer": "Sie beschreiben, welche Zustandsänderung durchgeführt werden soll, und übergeben die dafür nötigen Daten.",
    "category": "Redux: Basics",
    "difficulty": "easy"
  },
  {
    "id": 193,
    "question": "Was macht ein Reducer?",
    "answer": "Eine reine Funktion, die den aktuellen Zustand und eine Action entgegennimmt und einen neuen Zustand zurückgibt.",
    "category": "Redux: Basics",
    "difficulty": "easy"
  },
  {
    "id": 194,
    "question": "Wie erstellt man einen Store in Redux?",
    "answer": "Mit createStore, wobei man einen Reducer oder combineReducers übergibt.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 195,
    "question": "Wozu dient der Provider aus react-redux?",
    "answer": "Er stellt den Store dem gesamten React-Projekt über Context zur Verfügung.",
    "category": "Redux: Basics",
    "difficulty": "easy"
  },
  {
    "id": 196,
    "question": "Was macht der Hook useSelector?",
    "answer": "Er ermöglicht es, einen bestimmten Teil des Zustands aus dem Redux Store zu wählen und sich auf Änderungen zu abonnieren.",
    "category": "Redux: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 197,
    "question": "Was macht der Hook useDispatch?",
    "answer": "Er gibt eine Funktion zurück, mit der man Actions an den Store senden kann, um eine Zustandsänderung auszulösen.",
    "category": "Redux: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 198,
    "question": "Was ist ein Action Creator?",
    "answer": "Eine Funktion, die ein Action-Objekt erstellt, damit man sie nicht manuell schreiben muss.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 199,
    "question": "Warum muss ein Reducer eine reine Funktion sein?",
    "answer": "Damit Zustandsänderungen vorhersehbar und deterministisch bleiben.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 200,
    "question": "Was bedeutet der unidirektionale Datenfluss in Redux?",
    "answer": "Daten fließen immer in eine Richtung: Komponente → dispatch(Action) → Reducer → neuer Zustand → UI-Update.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 201,
    "question": "Was macht combineReducers in Redux?",
    "answer": "Es kombiniert mehrere Reducer zu einem, um den Store zu erstellen.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 202,
    "question": "Warum darf man den Zustand im Reducer nicht mutieren?",
    "answer": "Weil Redux Änderungen nur über Referenzvergleiche erkennt – Mutation führt zu Fehlern und falschen Updates.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 203,
    "question": "Wozu dient das Feld payload in einer Action?",
    "answer": "Um zusätzliche Daten zu übergeben, z. B. den Text eines neuen ToDos.",
    "category": "Redux: Basics",
    "difficulty": "easy"
  },
  {
    "id": 204,
    "question": "Wie verbindet man eine Komponente mit dem Redux Store?",
    "answer": "Mit useDispatch zum Senden von Actions und useSelector zum Auslesen des Zustands.",
    "category": "Redux: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 205,
    "question": "Wie kann man in Redux gleichzeitig ein Array und einen primitiven Wert speichern?",
    "answer": "Man verwendet ein Objekt mit mehreren Eigenschaften, z. B. todos und count.",
    "category": "Redux: Basics",
    "difficulty": "medium"
  },
  {
    "id": 206,
    "question": "Warum sollte man separate Dateien für Actions und Reducer verwenden?",
    "answer": "Damit der Code besser strukturiert, wartbar und skalierbar bleibt.",
    "category": "Redux: Structure",
    "difficulty": "medium"
  },
  {
    "id": 207,
    "question": "Was ist ein Slice im Redux Toolkit?",
    "answer": "Ein Teilzustand (Slice) mit Reducer, Actions und Action Creators an einem Ort.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 208,
    "question": "Worin unterscheidet sich createSlice vom klassischen Redux?",
    "answer": "Es erstellt automatisch Reducer, Actions und Action Creators und reduziert Boilerplate-Code.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 209,
    "question": "Was macht Immer im Redux Toolkit?",
    "answer": "Es ermöglicht, mutierenden Code zu schreiben, erzeugt aber intern einen neuen unveränderlichen Zustand.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 210,
    "question": "Was enthält das Objekt initialState in createSlice?",
    "answer": "Den Anfangszustand des jeweiligen Slices.",
    "category": "Redux Toolkit",
    "difficulty": "easy"
  },
  {
    "id": 211,
    "question": "Wozu dient die Eigenschaft name in createSlice?",
    "answer": "Sie wird als Präfix für die Action-Typen verwendet.",
    "category": "Redux Toolkit",
    "difficulty": "easy"
  },
  {
    "id": 212,
    "question": "Warum ist configureStore besser als createStore?",
    "answer": "Es ist modern, sicher und offiziell unterstützt – createStore gilt als veraltet.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 213,
    "question": "Wie verwendet man useSelector in einer Komponente mit Redux Toolkit?",
    "answer": "const counter = useSelector(state => state.counter) – wählt den benötigten Teil des Zustands.",
    "category": "Redux: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 214,
    "question": "Wie dispatcht man die Action increment aus einem Slice?",
    "answer": "increment importieren und dispatch(increment()) aufrufen.",
    "category": "Redux: Hooks",
    "difficulty": "easy"
  },
  {
    "id": 215,
    "question": "Was macht redux-thunk?",
    "answer": "Er ermöglicht asynchrone Actions (eine Action kann eine Funktion statt eines Objekts zurückgeben).",
    "category": "Redux Thunk",
    "difficulty": "medium"
  },
  {
    "id": 216,
    "question": "Wozu dient createAsyncThunk im Redux Toolkit?",
    "answer": "Es erstellt automatisch asynchrone Actions und generiert Actions für pending, fulfilled und rejected.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 217,
    "question": "Was macht extraReducers in createSlice?",
    "answer": "Er verarbeitet Actions, die nicht direkt im reducers-Objekt definiert sind (z. B. aus createAsyncThunk).",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 218,
    "question": "Welche drei Zustände hat eine asynchrone Action?",
    "answer": "pending (wird ausgeführt), fulfilled (erfolgreich), rejected (Fehler).",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 219,
    "question": "Wozu dient thunkApi als zweiter Parameter in createAsyncThunk?",
    "answer": "Um innerhalb der asynchronen Action Zugriff auf dispatch und getState zu erhalten.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 220,
    "question": "Wie übergibt man Parameter an eine asynchrone Action?",
    "answer": "Beim Dispatch-Aufruf, z. B. dispatch(fetchTodoById(5)).",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 221,
    "question": "Wo speichert man den Lade- und Fehlerstatus in einem Slice?",
    "answer": "Im State, z. B. in den Eigenschaften status und error.",
    "category": "Redux Toolkit",
    "difficulty": "medium"
  },
  {
    "id": 222,
    "question": "Warum sollte man asynchrone Logik im Thunk und nicht in der Komponente behandeln?",
    "answer": "Um Komponenten zu entlasten, Geschäftslogik zu zentralisieren und Wiederverwendung zu erleichtern.",
    "category": "Redux Thunk",
    "difficulty": "medium"
  },
  {
    "id": 223,
    "question": "Was macht useCallback?",
    "answer": "Es speichert die Definition einer Funktion zwischen den Renders einer Komponente zwischen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 224,
    "question": "Wann sollte man useCallback verwenden?",
    "answer": "Wenn eine Funktion an ein untergeordnetes memoisiertes (React.memo) Element übergeben wird oder wenn sie in den Abhängigkeiten eines Effekts steht.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 225,
    "question": "Was macht React.memo?",
    "answer": "Markiert eine Komponente als „rein“, sodass sie nur neu gerendert wird, wenn sich ihre Props ändern.",
    "category": "React: Performance",
    "difficulty": "medium"
  },
  {
    "id": 226,
    "question": "Was macht useMemo?",
    "answer": "Es speichert das Ergebnis einer Berechnung zwischen den Renders zwischen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 227,
    "question": "Worin unterscheidet sich useMemo von useCallback?",
    "answer": "useMemo gibt den Rückgabewert einer Funktion zurück, useCallback gibt die Funktion selbst zurück.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 228,
    "question": "Was sollte man im Abhängigkeitsarray von useMemo und useCallback angeben?",
    "answer": "Nur die Werte, bei deren Änderung die Funktion oder das Ergebnis neu berechnet werden sollen.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 229,
    "question": "Welche Funktion eignet sich für useMemo?",
    "answer": "Eine reine Funktion ohne Argumente, die nur von den angegebenen Abhängigkeiten abhängt.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 230,
    "question": "Wann berechnet useMemo den Wert neu?",
    "answer": "Nur wenn sich etwas aus dem Abhängigkeitsarray geändert hat.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 231,
    "question": "Welche typischen Aufgaben löst useMemo?",
    "answer": "Das Caching komplexer Berechnungen oder vorbereiteter Daten, die an Kindkomponenten weitergegeben werden.",
    "category": "React: Hooks",
    "difficulty": "medium"
  },
  {
    "id": 232,
    "question": "Was passiert, wenn man useCallback oder useMemo nicht verwendet, wenn man berechnete Werte oder Funktionen an Kindkomponenten übergibt?",
    "answer": "Kindkomponenten werden häufiger neu gerendert, auch wenn sich ihre Props tatsächlich nicht geändert haben.",
    "category": "React: Performance",
    "difficulty": "medium"
  }
]

